# lab4

## 练习1：分配并初始化一个进程控制块
alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。

请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）

首先完善下面的代码，为线程结构体进行最基本的初始化：
```
proc->state = PROC_UNINIT; // 设置进程为初始态
    proc->pid = -1;            // 设置进程pid的未初始化值
    proc->runs = 0;
    proc->kstack = 0;
    proc->need_resched = 0;
    proc->parent = NULL;
    proc->mm = NULL;
    memset(&(proc->context), 0, sizeof(struct context));
    proc->tf = NULL;
    proc->cr3 = boot_cr3; // 使用内核页目录表的基址
    proc->flags = 0;
    memset(proc->name, 0, PROC_NAME_LEN);
```
通过结构体里面的元素就可以看出来我们需要进行那些初始化。
由上面可知，补充的这个函数就是对新建立的页表进行初始化，首先就是状态设置为PROC_UNINIT，之后pid设置为-1，这说明这个线程是刚刚初始化的，还没有开始使用，同时，need_resched设置为零，只有idl线程才会设置为1，用来执行cpu_idel()函数，这样就能找到可以执行的线程，将其换进来。
其他就是父线程，内存空间都设置为NULL，存储寄存器状态的地址kstack也设置为0，还没有为其分配空间。
之后还有终端的时候保存寄存器状态的变量tf和设置为空，暂时不分配，同时本次实验申请的都是内核线程，共享内存，所以页表基址都是内核页表的基址。

在上述函数和switch.S中，结合对context的操作，可以将各种寄存器的值保存到context结构中。我们知道，context与进程的上下文切换有关，而tf则与中断处理相关，保存了所有的寄存器值。相比之下，context仅保存部分寄存器，用于切换上下文时的状态保持。

在proc_struct结构中，context保存进程的上下文，便于在进程切换时使用。在uCore操作系统中，每个进程在内核中都具有相对独立的运行环境（包括独立的内核堆栈和上下文）。通过使用context来保存寄存器的值，能够实现内核态之间的上下文切换。而具体的切换操作，则定义在switch.S文件中。

proc_struct中的tf则是一个指向当前中断帧的指针。当进程从用户态切换到内核态时，中断帧记录了中断前的进程状态。在从内核态返回用户态时，需要通过调整中断帧，恢复被中断时的寄存器值。tf的作用在于，当构造新的线程时，若要将控制权转移到该线程，需要通过中断返回的方式，因此必须伪造一个中断返回现场，以便将控制权正确交给新线程。

寄存器可以分为调用者保存（caller-saved）和被调用者保存（callee-saved）两类。context和tf的主要区别在于：context只保存了被调用者保存的寄存器，而tf保存了所有寄存器。此外，context在进程上下文切换中起作用，而tf主要在用户态与内核态的切换时发挥作用。




## 练习2：为新创建的内核线程分配资源
创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。因此，我们实际需要"fork"的东西就是stack和trapframe。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。
补充完整的do_fork()函数：
```
int
do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS) {
        goto fork_out;
    }
    ret = -E_NO_MEM;
    //LAB4:EXERCISE2 2211793
    /*
     * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.
     * MACROs or Functions:
     *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)
     *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack
     *   copy_mm:      process "proc" duplicate OR share process "current"'s mm according clone_flags
     *                 if clone_flags & CLONE_VM, then "share" ; else "duplicate"
     *   copy_thread:  setup the trapframe on the  process's kernel stack top and
     *                 setup the kernel entry point and stack of process
     *   hash_proc:    add proc into proc hash_list
     *   get_pid:      alloc a unique pid for process
     *   wakeup_proc:  set proc->state = PROC_RUNNABLE
     * VARIABLES:
     *   proc_list:    the process set's list
     *   nr_process:   the number of process set
     */

    //    1. call alloc_proc to allocate a proc_struct
    //    2. call setup_kstack to allocate a kernel stack for child process
    //    3. call copy_mm to dup OR share mm according clone_flag
    //    4. call copy_thread to setup tf & context in proc_struct
    //    5. insert proc_struct into hash_list && proc_list
    //    6. call wakeup_proc to make the new child process RUNNABLE
    //    7. set ret vaule using child proc's pid
    if ((proc = alloc_proc()) == NULL)
    {
        goto fork_out;
    }

    // 2. 调用 setup_kstack 为进程分配一个内核栈
    if (setup_kstack(proc) != 0)
    {
        goto bad_fork_cleanup_proc;
    }

    // 3. 调用 copy_mm 根据 clone_flags 复制或共享内存管理信息
    if (copy_mm(clone_flags, proc) != 0)
    {
        goto bad_fork_cleanup_kstack;
    }

    // 4. 调用 copy_thread 复制原进程的上下文信息
    copy_thread(proc, stack, tf);

    // 5. 将新进程插入到进程hash列表和进程列表中
    bool intr_flag;//禁用中断，相当于上锁防止执行过程被打断，进而保证pid的唯一性
    local_intr_save(intr_flag);
    {
        proc->pid = get_pid();
        hash_proc(proc);
        list_add(&proc_list, &(proc->list_link));
        nr_process++;
    }
    local_intr_restore(intr_flag);//解除禁用，相当于开锁

    // 6. 将新进程设置为就绪状态
    wakeup_proc(proc);

    // 7. 返回新进程的pid
    ret = proc->pid;

fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
    goto fork_out;
}
```


注意：三个错误分别是返回错误码，释放内核堆栈，释放进程控制块，这三个是逐步递进的，只有分配了进程控制块才能分配内核栈，释放时要按照相反顺序。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：

•	请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。
如果这个函数被同时调用，就可能两个进程同时执行 get_pid()得到相同的pid。但使用local_intr_save(intr_flag)这个函数，可以保存当前的中断状态并禁用中断，从而避免并行问题，确保操作的原子性，进而保证pid的唯一性。



## 练习3：编写proc_run 函数
proc_run用于将指定的进程切换到CPU上运行。它的大致执行步骤包括：

检查要切换的进程是否与当前正在运行的进程相同，如果相同则不需要切换。
禁用中断。你可以使用/kern/sync/sync.h中定义好的宏local_intr_save(x)和local_intr_restore(x)来实现关、开中断。
切换当前进程为要运行的进程。
切换页表，以便使用新进程的地址空间。/libs/riscv.h中提供了lcr3(unsigned int cr3)函数，可实现修改CR3寄存器值的功能。
实现上下文切换。/kern/process中已经预先编写好了switch.S，其中定义了switch_to()函数。可实现两个进程的context切换。
允许中断。

下面是函数补充完整的情况：
```
proc_run(struct proc_struct *proc) {
    if (proc != current) {
        // LAB4:EXERCISE3 2212915
        /*
        * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.
        * MACROs or Functions:
        *   local_intr_save():        Disable interrupts
        *   local_intr_restore():     Enable Interrupts
        *   lcr3():                   Modify the value of CR3 register
        *   switch_to():              Context switching between two processes
        */
        bool intr_flag;
        struct proc_struct *prev = current, *next = proc;
        local_intr_save(intr_flag);
        {
            current = proc;
            lcr3(next->cr3);
            switch_to(&(prev->context), &(next->context));
        }
        local_intr_restore(intr_flag);
    }
}
```

在本实验的执行过程中，创建且运行了几个内核线程？

通过kernel_thread函数、proc_init函数以及具体的实现结果可知，本次实验共建立了两个内核线程。首先是idleproc内核线程，该线程是最初的内核线程，完成内核中各个子线程的创建以及初始化。之后循环执行调度，执行其他进程。还有一个是initproc内核线程，该线程主要是为了显示实验的完成而打印出字符串"hello world"的内核线程。


## 补充完成Clock页替换算法（需要编程）

通过之前的练习，相信大家对 FIFO 的页面替换算法有了更深入的了解，现在请在我们给出的框架上，填写代码，实现 Clock 页替换算法页面（mm/swap_clock.c）。请在实验报告中简要说明你的设计实现过程。

_clock_init_mm函数
根据要求，初始化pra_list_head为空链表，然后初始化当前指针curr_ptr指向pra_list_head，表示当前页面替换位置为链表头，并将mm的私有成员指针指向pra_list_head，用于后续的页面替换算法操作。
```
static int _clock_init_mm(struct mm_struct *mm)
{     
     /*LAB3 EXERCISE 4: YOUR CODE*/ 
     //cprintf(" mm->sm_priv %x in fifo_init_mm\n",mm->sm_priv);
     list_init(&pra_list_head);
     curr_ptr = &pra_list_head;
     mm->sm_priv = &pra_list_head;
     return 0;
}
```
_clock_map_swappable函数
根据要求，使用list_add函数将页面page插入到页面链表pra_list_head的末尾,然后将页面的visited标志置为1，表示该页面已被访问。
```
static int _clock_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
{
    list_entry_t *entry=&(page->pra_page_link);
    assert(entry != NULL && curr_ptr != NULL);
    //record the page access situlation
    /*LAB3 EXERCISE 4: YOUR CODE*/
    // link the most recent arrival page at the back of the pra_list_head qeueue.
    list_entry_t *head=(list_entry_t*) mm->sm_priv;
    list_add(head, entry);
    page->visited = 1;
    return 0;
}
```
_clock_swap_out_victim函数
因为head指针不能使用le2page转成page结构体指针，所以首先需要进行检查。然后从链表末尾反向遍历，直至找到首个访问标记为0的项，将其移除可以交换到页链表中。在过程中遇到的页面如果访问标记为1，则将其改为0，表示该页面已被重新访问。
```
static int _clock_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)
{
     list_entry_t *head=(list_entry_t*) mm->sm_priv;
         assert(head != NULL);
     assert(in_tick==0);
     /* Select the victim */
     //(1)  unlink the  earliest arrival page in front of pra_list_head qeueue
     //(2)  set the addr of addr of this page to ptr_page
    while (1) {
        /*LAB3 EXERCISE 4: YOUR CODE*/ 
        // 编写代码
        
        // 遍历页面链表pra_list_head，查找最早未被访问的页面
        if(curr_ptr == head){
            curr_ptr = list_prev(curr_ptr);
            continue;
        }
        
        // 获取当前页面对应的Page结构指针
        // le2page将链表节点le所在地址向前(向低)偏移一定的长度,并返回一个Page*指针
        struct Page* curr_page = le2page(curr_ptr,pra_page_link);
        
        // 如果当前页面未被访问，则将该页面从页面链表中删除，并将该页面指针赋值给ptr_page作为换出页面
        if(curr_page->visited == 0){
            cprintf("curr_ptr %p\n", curr_ptr);
            curr_ptr = list_prev(curr_ptr);
            list_del(list_next(curr_ptr));
            *ptr_page = curr_page;
            return 0;
        }
        
        // 如果当前页面已被访问，则将visited标志置为0，表示该页面已被重新访问                
        curr_page->visited = 0;
        curr_ptr = list_prev(curr_ptr);
    }
    return 0;
}
```
④请回答如下问题：比较Clock页替换算法和FIFO算法的不同。

先进先出(First In First Out, FIFO)页替换算法：该算法总是淘汰最先进入内存的页，即选择在内存中驻留时间最久的页予以淘汰。只需把一个应用程序在执行过程中已调入内存的页按先后次序链接成一个队列，队列头指向内存中驻留时间最久的页，队列尾指向最近被调入内存的页。这样需要淘汰页时，从队列头很容易查找到需要淘汰的页。FIFO 算法只是在应用程序按线性顺序访问地址空间时效果才好，否则效率不高。因为那些常被访问的页，往往在内存中也停留得最久，结果它们因变“老”而不得不被置换出去。FIFO 算法的另一个缺点是，它有一种异常现象（Belady 现象），即在增加放置页的物理页帧的情况下，反而使页访问异常次数增多。

最久未使用(least recently used, LRU)算法：利用局部性，通过过去的访问情况预测未来的访问情况，我们可以认为最近还被访问过的页面将来被访问的可能性大，而很久没访问过的页面将来不太可能被访问。于是我们比较当前内存里的页面最近一次被访问的时间，把上一次访问时间离现在最久的页面置换出去。

时钟（Clock）页替换算法：是 LRU 算法的一种近似实现。时钟页替换算法把各个页面组织成环形链表的形式，类似于一个钟的表面。然后把一个指针（简称当前指针）指向最老的那个页面，即最先进来的那个页面。另外，时钟算法需要在页表项（PTE）中设置了一位访问位来表示此页表项对应的页当前是否被访问过。当该页被访问时，CPU 中的 MMU 硬件将把访问位置“1”。当操作系统需要淘汰页时，对当前指针指向的页所对应的页表项进行查询，如果访问位为“0”，则淘汰该页，如果该页被写过，则还要把它换出到硬盘上；如果访问位为“1”，则将该页表项的此位置“0”，继续访问下一个页。该算法近似地体现了 LRU 的思想，且易于实现，开销少，需要硬件支持来设置访问位。时钟页替换算法在本质上与 FIFO 算法是类似的，不同之处是在时钟页替换算法中跳过了访问位为 1 的页。

根据以上资料可知Clock算法设置了访问位置，用来表示此页表项对应的页当前是否被访问过，而FIFO算法总是淘汰最先进入内存的页，不考虑当前页是否被访问过。

## 练习5：阅读代码和实现手册，理解页表映射方式相关知识
首先我们如果采用一个大页来进行映射的话，大页的空间大小是2Mib，是我们正常使用的页的512倍，所以实际映射可以改为二级页表，比之前少了一级，同时函数get_pte()能够少执行一轮，两端非常相似的代码只需要执行上面的部分，同时页表项的偏移量能够减少，reverse的位置能够更多一些，但是大页又使得每一次换入换出的操作的负担加重，系统会操作更多更大的内存才能完成一次操作每次修改的数据基本不会超过一个页，所以用一个页来映射更精简。

# lab4

## 练习1：分配并初始化一个进程控制块
alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。

请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）

首先完善下面的代码，为线程结构体进行最基本的初始化：
```
proc->state = PROC_UNINIT; // 设置进程为初始态
    proc->pid = -1;            // 设置进程pid的未初始化值
    proc->runs = 0;
    proc->kstack = 0;
    proc->need_resched = 0;
    proc->parent = NULL;
    proc->mm = NULL;
    memset(&(proc->context), 0, sizeof(struct context));
    proc->tf = NULL;
    proc->cr3 = boot_cr3; // 使用内核页目录表的基址
    proc->flags = 0;
    memset(proc->name, 0, PROC_NAME_LEN);
```
通过结构体里面的元素就可以看出来我们需要进行那些初始化。
由上面可知，补充的这个函数就是对新建立的页表进行初始化，首先就是状态设置为PROC_UNINIT，之后pid设置为-1，这说明这个线程是刚刚初始化的，还没有开始使用，同时，need_resched设置为零，只有idl线程才会设置为1，用来执行cpu_idel()函数，这样就能找到可以执行的线程，将其换进来。
其他就是父线程，内存空间都设置为NULL，存储寄存器状态的地址kstack也设置为0，还没有为其分配空间。
之后还有终端的时候保存寄存器状态的变量tf和设置为空，暂时不分配，同时本次实验申请的都是内核线程，共享内存，所以页表基址都是内核页表的基址。

在上述函数和switch.S中，结合对context的操作，可以将各种寄存器的值保存到context结构中。我们知道，context与进程的上下文切换有关，而tf则与中断处理相关，保存了所有的寄存器值。相比之下，context仅保存部分寄存器，用于切换上下文时的状态保持。

在proc_struct结构中，context保存进程的上下文，便于在进程切换时使用。在uCore操作系统中，每个进程在内核中都具有相对独立的运行环境（包括独立的内核堆栈和上下文）。通过使用context来保存寄存器的值，能够实现内核态之间的上下文切换。而具体的切换操作，则定义在switch.S文件中。

proc_struct中的tf则是一个指向当前中断帧的指针。当进程从用户态切换到内核态时，中断帧记录了中断前的进程状态。在从内核态返回用户态时，需要通过调整中断帧，恢复被中断时的寄存器值。tf的作用在于，当构造新的线程时，若要将控制权转移到该线程，需要通过中断返回的方式，因此必须伪造一个中断返回现场，以便将控制权正确交给新线程。

寄存器可以分为调用者保存（caller-saved）和被调用者保存（callee-saved）两类。context和tf的主要区别在于：context只保存了被调用者保存的寄存器，而tf保存了所有寄存器。此外，context在进程上下文切换中起作用，而tf主要在用户态与内核态的切换时发挥作用。




## 练习2：为新创建的内核线程分配资源
创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。因此，我们实际需要"fork"的东西就是stack和trapframe。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。
补充完整的do_fork()函数：
```
int
do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS) {
        goto fork_out;
    }
    ret = -E_NO_MEM;
    //LAB4:EXERCISE2 2211793
    /*
     * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.
     * MACROs or Functions:
     *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)
     *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack
     *   copy_mm:      process "proc" duplicate OR share process "current"'s mm according clone_flags
     *                 if clone_flags & CLONE_VM, then "share" ; else "duplicate"
     *   copy_thread:  setup the trapframe on the  process's kernel stack top and
     *                 setup the kernel entry point and stack of process
     *   hash_proc:    add proc into proc hash_list
     *   get_pid:      alloc a unique pid for process
     *   wakeup_proc:  set proc->state = PROC_RUNNABLE
     * VARIABLES:
     *   proc_list:    the process set's list
     *   nr_process:   the number of process set
     */

    //    1. call alloc_proc to allocate a proc_struct
    //    2. call setup_kstack to allocate a kernel stack for child process
    //    3. call copy_mm to dup OR share mm according clone_flag
    //    4. call copy_thread to setup tf & context in proc_struct
    //    5. insert proc_struct into hash_list && proc_list
    //    6. call wakeup_proc to make the new child process RUNNABLE
    //    7. set ret vaule using child proc's pid
    if ((proc = alloc_proc()) == NULL)
    {
        goto fork_out;
    }

    // 2. 调用 setup_kstack 为进程分配一个内核栈
    if (setup_kstack(proc) != 0)
    {
        goto bad_fork_cleanup_proc;
    }

    // 3. 调用 copy_mm 根据 clone_flags 复制或共享内存管理信息
    if (copy_mm(clone_flags, proc) != 0)
    {
        goto bad_fork_cleanup_kstack;
    }

    // 4. 调用 copy_thread 复制原进程的上下文信息
    copy_thread(proc, stack, tf);

    // 5. 将新进程插入到进程hash列表和进程列表中
    bool intr_flag;//禁用中断，相当于上锁防止执行过程被打断，进而保证pid的唯一性
    local_intr_save(intr_flag);
    {
        proc->pid = get_pid();
        hash_proc(proc);
        list_add(&proc_list, &(proc->list_link));
        nr_process++;
    }
    local_intr_restore(intr_flag);//解除禁用，相当于开锁

    // 6. 将新进程设置为就绪状态
    wakeup_proc(proc);

    // 7. 返回新进程的pid
    ret = proc->pid;

fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
    goto fork_out;
}
```


注意：三个错误分别是返回错误码，释放内核堆栈，释放进程控制块，这三个是逐步递进的，只有分配了进程控制块才能分配内核栈，释放时要按照相反顺序。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：

•	请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。
如果这个函数被同时调用，就可能两个进程同时执行 get_pid()得到相同的pid。但使用local_intr_save(intr_flag)这个函数，可以保存当前的中断状态并禁用中断，从而避免并行问题，确保操作的原子性，进而保证pid的唯一性。



## 练习3：编写proc_run 函数
proc_run用于将指定的进程切换到CPU上运行。它的大致执行步骤包括：

检查要切换的进程是否与当前正在运行的进程相同，如果相同则不需要切换。
禁用中断。你可以使用/kern/sync/sync.h中定义好的宏local_intr_save(x)和local_intr_restore(x)来实现关、开中断。
切换当前进程为要运行的进程。
切换页表，以便使用新进程的地址空间。/libs/riscv.h中提供了lcr3(unsigned int cr3)函数，可实现修改CR3寄存器值的功能。
实现上下文切换。/kern/process中已经预先编写好了switch.S，其中定义了switch_to()函数。可实现两个进程的context切换。
允许中断。

下面是函数补充完整的情况：
```
proc_run(struct proc_struct *proc) {
    if (proc != current) {
        // LAB4:EXERCISE3 2212915
        /*
        * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.
        * MACROs or Functions:
        *   local_intr_save():        Disable interrupts
        *   local_intr_restore():     Enable Interrupts
        *   lcr3():                   Modify the value of CR3 register
        *   switch_to():              Context switching between two processes
        */
        bool intr_flag;
        struct proc_struct *prev = current, *next = proc;
        local_intr_save(intr_flag);
        {
            current = proc;
            lcr3(next->cr3);
            switch_to(&(prev->context), &(next->context));
        }
        local_intr_restore(intr_flag);
    }
}
```

在本实验的执行过程中，创建且运行了几个内核线程？

通过kernel_thread函数、proc_init函数以及具体的实现结果可知，本次实验共建立了两个内核线程。首先是idleproc内核线程，该线程是最初的内核线程，完成内核中各个子线程的创建以及初始化。之后循环执行调度，执行其他进程。还有一个是initproc内核线程，该线程主要是为了显示实验的完成而打印出字符串"hello world"的内核线程。


## 扩展练习
说明语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);是如何实现开关中断的？

local_intr_save(intr_flag); 和 local_intr_restore(intr_flag); 是成对使用的函数，通常用于控制中断的开启与关闭，特别是在关键代码区域的执行期间。这两个函数在该区域的开始和结束处配合使用，以确保在执行过程中不会发生中断。

local_intr_save(intr_flag); 的功能是保存当前的中断状态并关闭中断。它首先将当前中断状态保存在 intr_flag 变量中，然后关闭所有中断，以确保关键代码段不被打断。

local_intr_restore(intr_flag); 则用于恢复之前保存的中断状态。它会将 intr_flag 中存储的中断状态重新应用，恢复到调用 local_intr_save 之前的状态。

这对函数的具体实现依赖于底层硬件和操作系统。在某些系统中，这可能需要使用特定的硬件指令或系统调用来实现相关功能，因此其代码实现会因系统不同而有所差异。
